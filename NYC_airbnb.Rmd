---
title: "Apprentissage Statistique"
subtitle: "New York city Airbnb"
author: "Duong Nguyen & Julien Le Mauff"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document: default
---

```{r setup, include=F, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = T)
```

# Import Packages

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
library(caret)
library(dplyr)
library(tidyr)
library(psych)
library(caret)
library(ggplot2)
library(ggmap)
library(lubridate)
library(stringr)
library(forcats)
library(gridExtra)
library(vroom)
```

# Listings data

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
# Get the file names of every csv file with the pattern "listing_"
# files <- fs::dir_ls(glob = "listing_*csv")
# 
# # Column we keep from the listings csv files
# listings_keep <- c("id", "price", "state", "host_is_superhost",
#                    "neighbourhood_group_cleansed", "neighbourhood_cleansed",
#                    "latitude","longitude", "property_type", "accommodates",
#                    "bedrooms", "beds", "bed_type", "cleaning_fee",
#                    "minimum_nights", "availability_365",
#                    "review_scores_rating","cancellation_policy")
# 
# # Import all the files and bind them together
# listings <- vroom(files, col_select = listings_keep)
# 
# # Keep only observations with state == "NY"
# listings <- listings[listings$state=="NY",]
# 
# # Drop state column
# listings <- listings[ , !(names(listings) %in% c("state"))]
# 
# # Eliminate all duplicates listings
# listings <- listings[!duplicated(listings$id),]
# 
# # Eliminate observations with missing id
# listings <- listings[complete.cases(listings$id),]
# 
# # Eliminate the $ sign on price
# listings$price = as.numeric(gsub("[\\$,]", "", listings$price))
# 
# # Eliminate the $ sign on cleaning fee
# listings$cleaning_fee = as.numeric(gsub("[\\$,]", "", listings$cleaning_fee))
# 
# # Export the listing compiled database
# write.csv(listings, "Data/data_compiled.csv", row.names = FALSE)
```

# Import compiled data

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
data <- read.csv("/Users/lemauffjulien/Documents/Documents/Master 2/S2/NYC_Airbnb/Data/data_compiled.csv", sep = ",")
```

## Data manipulations / Cleaning the data

### Dealing with missing values

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
na_count <- t(data %>% summarise_each(funs(sum(is.na(.)))))

# ===== ===== Price ===== =====

# For the sake of simplicity, we delete the observations where price 
# is null or has missing values

data[is.na(data$price), "price"] <- 0
data <- data %>% filter(price > 0)

# ===== ===== Bedrooms ===== =====

data$bedrooms <- as.integer(data$bedrooms)
# histogram(data$bedrooms)

# Given the distribution, we could replace the 76 missing values
# of bedrooms (the number of bedrooms) by the median grouped
# by property type, number of accomodates and bed types.

# We would use the median because we want an integer and not a float
# (numbers with commas). But since we have a large enough number of observation
# we prefer to remove these NA

data[is.na(data$bedrooms), "bedrooms"] <- 0
data <- data %>% filter(bedrooms > 0)

# ===== ===== Beds ===== =====

data$beds <- as.integer(data$beds)
# histogram(data$beds)

# Given the distribution, we could replace the 479 missing values
# of beds (the number of beds) by the median grouped
# by property type, number of accomodates and bedrooms.

# We would use the median because we want an integer and not a float
# (numbers with commas). But since we have a large enough number of 
# observations we prefer to remove these NA

data[is.na(data$beds), "beds"] <- 0
data <- data %>% filter(beds > 0)


# ===== ===== Cleaning fee ===== =====

# A cleaning fee is a one-time fee charged by hosts to cover the cost of
# cleaning their holiday rental when guests depart. Not all hosts charge
# this fee. Some incorporate it into their nightly rate.

# Therefore it is safe to assume that when there is no value for this
# variable it simply means that the host didn't charge

data[is.na(data$cleaning_fee), "cleaning_fee"] <- 0

# ===== ===== Host is superhost ===== =====

# There is only 92 missing values out of more than 78 000
# Therefore we will just replace them it by the most common value (f)

data[is.na(data$host_is_superhost),
     "host_is_superhost"] <- "f"

# ===== ===== Review scores rating ===== =====

data$rating <- as.integer(data$review_scores_rating) 

data <- data %>% 
  mutate (rating =  ifelse(rating >= 19, rating+42, rating),
          rating =  ifelse(rating == 2, 100, rating))

# Given that the distribution is skewed on the right, we will use the
# median to approximate the missing values grouped by neighbours,
# property types, type of beds and if the host is a superhost.

data <- data %>%
  group_by(neighbourhood_cleansed,bed_type,property_type,host_is_superhost) %>%
  mutate(rating=ifelse(is.na(rating),  median(rating,na.rm=T), rating)) %>%
  ungroup()

# There is still 202 missing values so we could just replace them with the
# overall score median or we remove them since we have enough observations

data[is.na(data$rating),
     "rating"] <- median(data$rating,
                                       na.rm = T)

data <- data[,-c(16)]
names(data)[names(data) == "rating"] <- "review_scores_rating"

# ===== ===== Cancellation policy ===== =====

# There is only 1 missing values so we remove it

data <- na.omit(data)

```

### Dealing with categorical variables with too many levels

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
# # ===== ===== Type de logement ===== =====

# We groups all 40 subgroups of logement types into 5 big groups

Appartment <- c("Aparthotel","Serviced apartment", "Loft",
                "Condominium", "Apartment")

House <- c("Barn", "Timeshare", "Dome house", "Lighthouse",
           "Casa particular (Cuba)", "Houseboat", "Villa",
           "Treehouse", "Earth house", "Cottage", "Tiny house",
           "Townhouse", "House", "Bungalow", "Cabin")

Shared_room <- c("Dorm", "Hostel", "Guesthouse", "Timeshare")

Private_room <- c("Farm stay", "Bed and breakfast", "Resort", "Hotel",
                  "Boutique hotel", "Guest suite", "In-law")

Other <- c("Train", "Bus", "Boat", "Other", "Cave", "Island",
           "Camper/RV", "Yurt", "Castle", "Tent", "Nature lodge", 
           "Pension (South Korea)")

data$property_type <- as.character(data$property_type)

data <-
  mutate(data,
         property_type = ifelse(property_type %in% Appartment,
                                "Appartment", property_type),
         property_type = ifelse(property_type %in% House,
                                "House", property_type),
         property_type = ifelse(property_type %in% Shared_room,
                                "Shared Room", property_type),
         property_type = ifelse(property_type %in% Private_room,
                                "Private Room", property_type),
         property_type = ifelse(property_type %in% Other,
                                "Others", property_type))

data$property_type <- as.factor(data$property_type)
```

## Export the cleaned database 

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
write.csv(data, "/Users/lemauffjulien/Documents/Documents/Master 2/S2/NYC_Airbnb/Data/clean_data.csv", row.names = FALSE)
```

# Data analysis / Data visualisation

## Import the clean database

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
#<<<<<<< Updated upstream
# data <- read.csv("/Users/ngyduong/Documents/Machine Learning/Github_projects/NewYork_Airbnb/NYC_Airbnb/Data/clean_data.csv",
#                  sep = ",")

data <- read.csv("/Users/lemauffjulien/Documents/Documents/Master2/
                 S2/NYC_Airbnb/Data/clean_data.csv", sep = ",")
#>>>>>>> Stashed changes
```

## Data visualisation

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
# theme <- theme(plot.title = element_text(hjust = 0.5), 
#                plot.background = element_rect(fill = "#BFD5E3"))
# tag_source <- "Source: Inside Airbnb"
```

### Density of discrete variables

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
# data$bedrooms <- as.factor(data$bedrooms)
# data$beds <- as.factor(data$beds)
# data$accommodates <- as.factor(data$accommodates)
# 
# features_discrete <- names(select_if(data[,-c(1,3:4)],is.factor))
# # Without host_id, last_review and listing_id
# 
# for (i in features_discrete) {
#   plot <-ggplot(mapping = aes_string(x = fct_infreq(data[,i]), 
#                                      fill = data[,i])) +
#     geom_bar(width = 1, colour = "black", show.legend = F) + 
#     theme + labs(x = "", y = "Fréquence", caption = tag_source) +
#     ggtitle(i)
#   print(plot)
# }
# ```
# 
# ### Density and log of continuous variables 
# 
# ```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
# features_numeric <- names(select_if(data[,-c(1,9:10)],is.numeric))
# # Without listing_id, latitude and longitude
# 
# for (i in features_numeric){
#   
#   plot <- ggplot(mapping = aes(x = data[,i])) +
#     geom_histogram(colour="black", fill="dodgerblue3",
#                    aes(y = ..density..)) + theme + ggtitle(i) +
#     labs(x = "", y = "Density", caption = tag_source) + 
#     geom_density(fill = "cyan", colour = "cyan", 
#                  alpha = 0.5, lwd=0.5, linetype = "dashed") 
#   
#   log_plot <- ggplot(mapping = aes(x = log(data[,i]))) +
#     geom_histogram(colour="black", fill="forestgreen",
#                    aes(y= ..density..)) + theme + 
#     labs(x = "", y = "Density", caption = tag_source) + 
#     ggtitle(paste("log of",i)) +
#     geom_density(fill = "olivedrab2", colour = "olivedrab2", 
#                  alpha = 0.5, lwd=0.5, linetype = "dashed") 
#   
#   grid.arrange(plot, log_plot, ncol=2)
# }
```

### Boxplot 

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
# # # ===== ===== Prix par arrondissement ===== =====
# ggplot(data, aes(x = neighbourhood_group_cleansed, y = log(price))) +
#   geom_boxplot(outlier.colour = "darkblue", outlier.size = 0.5,
#                color="deepskyblue", fill="cyan", alpha=0.2) + 
#   ggtitle("Prix des airbnb par nuit en moyenne (en log) par arondissement") +
#   labs(x = "Arrondissements", y = "Prix par nuit en moyenne (en log)",
#        caption = tag_source) + theme
# 
# # # ===== ===== Prix par arrondissement et type de logement ===== =====
# 
# ggplot(data, aes(x = neighbourhood_group_cleansed, y = log(price), 
#                  fill = property_type)) +
#   geom_boxplot(outlier.colour = "darkblue", outlier.size = 0.5) + 
#   ggtitle("Prix des airbnb par nuit en moyenne (en log) 
#           par arondissement et par type de logement") +
#   scale_fill_discrete(name = "Type de logement") + theme +
#   labs(x = "Arrondissement", y = "Prix par nuit en moyenne (en log)",
#        caption = tag_source) 
# 
# # # ===== ===== Répartition des logements par arrondissement ===== =====
# 
# ggplot(data, aes(x = neighbourhood_group_cleansed, fill = property_type)) +
#   geom_bar(width = 1, colour = "black", show.legend = T) +
#   ggtitle("Répartition des logements par arrondissement") +
#   scale_fill_discrete(name = "Type de logement") + theme + 
#   labs(x = "Arrondissement", y = "Fréquence", caption = tag_source) 
```

### Spatial Heatmap

#### Evolution des prix par quartier

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
<<<<<<< Updated upstream
# by_neighbourhood <- group_by(data, neighbourhood_cleansed) %>% 
#   summarise(longitude = median(longitude), 
#             latitude = median(latitude), 
#             prix_median = median(price),
#             prix_moyen = mean(price),
#             scores_moyen = mean(review_scores_rating))
# 
# for (i in by_neighbourhood$neighbourhood_cleansed) {
#   for (j in data$neighbourhood_cleansed) {
#     if (i == j) {
#       a <- unique(as.character(data[data$neighbourhood_cleansed==j,
#                                    "neighbourhood_group_cleansed"]))
#       by_neighbourhood[by_neighbourhood$neighbourhood_cleansed==i,
#                        "Arrondissements"] <- a
#     }
#   }
# }
# 
# by_neighbourhood$Arrondissements <- 
#   as.factor(by_neighbourhood$Arrondissements)
# 
# height <- max(data$latitude) - min(data$latitude)
# width <- max(data$longitude) - min(data$longitude)
# borders <- c(bottom  = min(data$latitude)  - 0.1 * height,
#              top     = max(data$latitude)  + 0.1 * height,
#              left    = min(data$longitude) - 0.1 * width,
#              right   = max(data$longitude) + 0.1 * width)
# 
# map <- get_stamenmap(borders, zoom = 11, maptype = "terrain")
# 
# # # ===== ===== Prix moyen par quartiers ===== =====
# ggmap(map) +
#   geom_point(by_neighbourhood, 
#              mapping = aes(x = longitude, y = latitude, 
#                            col = prix_moyen,
#                            shape = Arrondissements)) +
#   scale_colour_gradient(low = "blue", high = "red") + theme +
#   labs(x = "", y = "", caption = tag_source, col = "Prix moyen") + 
#   ggtitle("Prix moyen par quartier") 
# 
# # # ===== ===== Score median par quartiers ===== =====
# ggmap(map) +
#   geom_point(by_neighbourhood, 
#              mapping = aes(x = longitude, y = latitude, 
#                            col = scores_moyen,
#                            shape = Arrondissements)) +
#   scale_colour_gradient(low = "blue", high = "red") + theme +
#   labs(x = "", y = "", caption = tag_source, col = "Score moyen") + 
#   ggtitle("Score median par quartier") 
=======
by_neighbourhood <- group_by(data, neighbourhood_cleansed) %>% 
  summarise(longitude = median(longitude), 
            latitude = median(latitude), 
            prix_median = median(price),
            prix_moyen = mean(price),
            scores_moyen = mean(review_scores_rating))

for (i in by_neighbourhood$neighbourhood_cleansed) {
  for (j in data$neighbourhood_cleansed) {
    if (i == j) {
      a <- unique(as.character(data[data$neighbourhood_cleansed==j,
                                   "neighbourhood_group_cleansed"]))
      by_neighbourhood[by_neighbourhood$neighbourhood_cleansed==i,
                       "Arrondissements"] <- a
    }
  }
}

by_neighbourhood$Arrondissements <- as.factor(by_neighbourhood$Arrondissements)

height <- max(data$latitude) - min(data$latitude)
width <- max(data$longitude) - min(data$longitude)
borders <- c(bottom  = min(data$latitude)  - 0.1 * height,
             top     = max(data$latitude)  + 0.1 * height,
             left    = min(data$longitude) - 0.1 * width,
             right   = max(data$longitude) + 0.1 * width)

map <- get_stamenmap(borders, zoom = 11, maptype = "terrain")

# # ===== ===== Prix moyen par quartiers ===== =====
ggmap(map) +
  geom_point(by_neighbourhood, 
             mapping = aes(x = longitude, y = latitude, 
                           col = prix_moyen,
                           shape = Arrondissements)) +
  scale_colour_gradient(low = "blue", high = "red") + theme +
  labs(x = "", y = "", caption = tag_source, col = "Prix moyen") + 
  ggtitle("Prix moyen par quartier") 

# # ===== ===== Score median par quartiers ===== =====
ggmap(map) +
  geom_point(by_neighbourhood, 
             mapping = aes(x = longitude, y = latitude, 
                           col = scores_moyen,
                           shape = Arrondissements)) +
  scale_colour_gradient(low = "blue", high = "red") + theme +
  labs(x = "", y = "", caption = tag_source, col = "Score moyen") + 
  ggtitle("Score median par quartier") 
>>>>>>> Stashed changes
```

#### Evolution des prix par Arrondissement

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
# by_borough <- group_by(data, neighbourhood_group_cleansed) %>% 
#   summarise(longitude = median(longitude), 
#             latitude = median(latitude),
#             prix_moyen = mean(price),
#             prix_median = median(price),
#             scores_moyen = mean(review_scores_rating),
#             disponibilité_moyen = mean(availability_365))
# 
# # # ===== ===== Prix moyen par arrondissements ===== =====
# 
# ggmap(map) +
#   geom_point(by_borough, shape = 18,
#              mapping = aes(x = longitude, y = latitude,
#                                        col = prix_moyen, 
#                                        size = disponibilité_moyen)) +
#   scale_colour_gradient(low = "blue", high = "red") + 
#   theme + labs(x = "", y = "", caption = tag_source, 
#                size = "Disponibilité annuel moyen",
#                col = "Prix moyen") +
#   ggtitle("Prix moyen (en log) et disponibilité 
#           par arrondissements") +
#   geom_label(by_borough, 
#              mapping = aes(longitude, latitude, 
#                            label = neighbourhood_group_cleansed),
#              size = 1.5, fontface = "bold", 
#              nudge_x = 0.015, nudge_y = -0.03)
```

