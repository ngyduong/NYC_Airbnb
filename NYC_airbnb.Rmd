---
title: "Apprentissage Statistique"
subtitle: "New York city Airbnb"
subsubtitle: "RStudio version 1.2.5001 & R version 3.6.2 (2019-12-12)"
author: "Duong Nguyen & Julien Le Mauff"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document: default
---

```{r setup, include=F, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = T)
```

# Import Packages

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
library(caret)
library(dplyr)
library(tidyr)
library(psych)
library(caret)
library(ggplot2)
library(ggmap)
library(lubridate)
library(stringr)
library(forcats)
library(gridExtra)
library(vroom)
library(corrplot)
```

# Import Raw data

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
# Get the file names of every csv file with the pattern "listing_"
files <- fs::dir_ls(glob = "listing_*csv")

# Column we keep from the listings csv files
listings_keep <- c("id", "price", "state", "host_is_superhost",
                   "neighbourhood_group_cleansed", "neighbourhood_cleansed",
                   "latitude","longitude", "property_type", "accommodates",
                   "bedrooms", "beds", "bed_type", "cleaning_fee",
                   "minimum_nights", "availability_365",
                   "review_scores_rating","cancellation_policy")

# Import all the files and bind them together
listings <- vroom(files, col_select = listings_keep, delim= ",")

# Keep only observations with state == "NY"
listings <- listings[listings$state=="NY",]

# Drop state column
listings <- listings[ , !(names(listings) %in% c("state"))]

# Eliminate all duplicates listings
listings <- listings[!duplicated(listings$id),]

# Eliminate observations with missing id
listings <- listings[complete.cases(listings$id),]

# Eliminate the $ sign on price
listings$price = as.numeric(gsub("[\\$,]", "", listings$price))

# Eliminate the $ sign on cleaning fee
listings$cleaning_fee = as.numeric(gsub("[\\$,]", "", listings$cleaning_fee))

# Eliminate observations in which the id is non numeric
id_remove <- grep("[^0-9]",listings$id)
listings <- listings[-id_remove, ]

# Export the listing compiled database
write.csv(listings, "Data/data_compiled.csv", row.names = FALSE)
```

# Data manipulations / Cleaning the data

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
data <- read.csv("/Users/ngyduong/Documents/Machine Learning/Github_projects/NewYork_Airbnb/NYC_Airbnb/Data/data_compiled.csv", sep = ",")
```

## Dealing with missing values

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
# ===== ===== NA count ===== =====

na_count <- t(data %>% summarise_each(funs(sum(is.na(.)))))

# ===== ===== Check the class of each variables ===== =====

lapply(data,class)

# ===== ===== Price ===== ====

# For the sake of simplicity, we delete the observations where price is null

data <- data %>% filter(price > 0) 

# ===== ===== Bedrooms ===== =====

histogram(data$bedrooms)

# Given the distribution, we could replace the 112 missing values
# of bedrooms (the number of bedrooms) by the median grouped
# by property type, number of accomodates and bed types.

# We would use the median because we want an integer and not a float
# (numbers with commas). Furthermore, the median works great against 
# skewed distribution and outliers. 

data <- data %>%
  group_by(
    property_type,
    accommodates,
    bed_type) %>%
  mutate(bedrooms=ifelse(is.na(bedrooms),
                         median(bedrooms,na.rm = T),bedrooms)) %>%
  ungroup()

# ===== ===== Beds ===== =====

histogram(data$beds)

# Given the distribution, we could replace the 174 missing values
# of beds (the number of beds) by the median grouped
# by property type, number of accomodates and bed types

# We would use the median because we want an integer and not a float
# (numbers with commas). Furthermore, the median works great against 
# skewed distribution and outliers. 

data <- data %>%
  group_by(
    property_type,
    accommodates,
    bed_type) %>%
  mutate(beds=ifelse(is.na(beds),
                         median(beds,na.rm=T),beds)) %>%
  ungroup()

# ===== ===== Cleaning fee ===== =====

# A cleaning fee is a one-time fee charged by hosts to cover the cost of
# cleaning their holiday rental when guests depart. Not all hosts charge
# this fee. Some incorporate it into their nightly rate.

# Therefore it is safe to assume that when there is no value for this
# variable it simply means that the host didn't charge

data[is.na(data$cleaning_fee), "cleaning_fee"] <- 0

# ===== ===== Host is superhost ===== =====

# There is only 94 missing values out of more than 78 000
# Therefore we will just replace them by the most common value (f)

data[is.na(data$host_is_superhost),"host_is_superhost"] <- "f"

# ===== ===== Review scores rating ===== =====

histogram(data$review_scores_rating)

# Given that the distribution is skewed on the right, we will use the
# median to approximate the missing values grouped by neighbours,
# property types, type of beds and if the host is a superhost.

data <- data %>%
  group_by(neighbourhood_cleansed,
           bed_type,
           property_type,
           host_is_superhost) %>%
  mutate(review_scores_rating=ifelse(is.na(review_scores_rating), 
                                     median(review_scores_rating,na.rm=T),
                                     review_scores_rating)) %>%
  ungroup()

# There is still 363 missing values so we could just replace them with the
# overall score median or we remove them since we have enough observations

data[is.na(data$review_scores_rating), "review_scores_rating"] <-
  median(data$review_scores_rating, na.rm = T)

# ===== ===== Cancellation policy ===== =====

# There is only 1 missing values so we remove it

data <- data[complete.cases(data$cancellation_policy),]
```

## Dealing with categorical variables 

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
# # ===== ===== Type de logement ===== =====

# We groups all 40 subgroups of logement types into 5 big groups

Appartment <- c("Aparthotel","Serviced apartment", "Loft",
                "Condominium", "Apartment")

House <- c("Barn", "Timeshare", "Dome house", "Lighthouse",
           "Casa particular (Cuba)", "Houseboat", "Villa",
           "Treehouse", "Earth house", "Cottage", "Tiny house",
           "Townhouse", "House", "Bungalow", "Cabin")

Shared_room <- c("Dorm", "Hostel", "Guesthouse", "Timeshare")

Private_room <- c("Farm stay", "Bed and breakfast", "Resort", "Hotel",
                  "Boutique hotel", "Guest suite", "In-law")

Other <- c("Train", "Bus", "Boat", "Other", "Cave", "Island",
           "Camper/RV", "Yurt", "Castle", "Tent", "Nature lodge",
           "Pension (South Korea)")

data$property_type <- as.character(data$property_type)

data <-
  mutate(data,
         property_type = ifelse(property_type %in% Appartment,
                                "Appartment", property_type),
         property_type = ifelse(property_type %in% House,
                                "House", property_type),
         property_type = ifelse(property_type %in% Shared_room,
                                "SharedRoom", property_type),
         property_type = ifelse(property_type %in% Private_room,
                                "PrivateRoom", property_type),
         property_type = ifelse(property_type %in% Other,
                                "Others", property_type))

# # ===== ===== Host is superhost ===== =====

# We change from "t" to "Truee and "f" to False
data <- mutate(data, 
               host_is_superhost = ifelse(host_is_superhost=="t", 
                                          "True", "False"))

# # ===== ===== Bed Types ===== =====

data$bed_type <- as.character(data$bed_type)

# We change from "Pull-out Sofa" to "PullOut_Sofa" and "Real Bed" to "Real Bed"
data <- mutate(data, 
               bed_type = ifelse(bed_type=="Pull-out Sofa", 
                                 "PullOut_Sofa", bed_type),
               bed_type = ifelse(bed_type=="Real Bed",
                                 "RealBed", bed_type))

# # ===== ===== Borough (neighbourhood_group_cleansed) ===== =====

data$neighbourhood_group_cleansed <- as.character(data$neighbourhood_group_cleansed)

# We change from "Pull-out Sofa" to "PullOut_Sofa" and "Real Bed" to "Real Bed"
data <- mutate(data, 
               neighbourhood_group_cleansed = 
                 ifelse(neighbourhood_group_cleansed=="Staten Island", 
                        "StatenIsland", neighbourhood_group_cleansed))
```

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
write.csv(data, "/Users/ngyduong/Documents/Machine Learning/Github_projects/NewYork_Airbnb/NYC_Airbnb/Data/clean_data.csv", row.names = FALSE) 
```

# Data analysis / Data visualisation

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
# Nguyen Duong
data <- read.csv("/Users/ngyduong/Documents/Machine Learning/Github_projects/NewYork_Airbnb/NYC_Airbnb/Data/clean_data.csv", sep = ",")

# Julien Le Mauff
data <- read.csv("/Users/lemauffjulien/Documents/Documents/Master2/
                 S2/NYC_Airbnb/Data/clean_data.csv", sep = ",")
```

## Data visualisation

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
theme <- theme(plot.title = element_text(hjust = 0.5),
               plot.background = element_rect(fill = "#BFD5E3"))
tag_source <- "Source: Inside Airbnb"
```

### Density of discrete variables

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
features_discrete <- names(select_if(data[,-c(1)],is.factor))
# Without id

for (i in features_discrete) {
  plot <-ggplot(mapping = aes_string(x = fct_infreq(data[,i]),
                                     fill = data[,i])) +
    geom_bar(width = 1, colour = "black", show.legend = F) +
    theme + labs(x = "", y = "Fréquence", caption = tag_source) +
    ggtitle(i)
  print(plot)
}
```

### Density and log of continuous variables

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
features_numeric <- names(select_if(data[,-c(1,6:7)],is.numeric))
# Without id, latitude and longitude

for (i in features_numeric){

  plot <- ggplot(mapping = aes(x = data[,i])) +
    geom_histogram(colour="black", fill="dodgerblue3",
                   aes(y = ..density..)) + theme + ggtitle(i) +
    labs(x = "", y = "Density", caption = tag_source) +
    geom_density(fill = "cyan", colour = "cyan",
                 alpha = 0.5, lwd=0.5, linetype = "dashed")

  log_plot <- ggplot(mapping = aes(x = log(data[,i]))) +
    geom_histogram(colour="black", fill="forestgreen",
                   aes(y= ..density..)) + theme +
    labs(x = "", y = "Density", caption = tag_source) +
    ggtitle(paste("log of",i)) +
    geom_density(fill = "olivedrab2", colour = "olivedrab2",
                 alpha = 0.5, lwd=0.5, linetype = "dashed")

  grid.arrange(plot, log_plot, ncol=2)
}
```

### Boxplot 

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
# # ===== ===== Prix par arrondissement ===== =====
ggplot(data, aes(x = neighbourhood_group_cleansed, y = log(price))) +
  geom_boxplot(outlier.colour = "darkblue", outlier.size = 0.5,
               color="deepskyblue", fill="cyan", alpha=0.2) +
  ggtitle("Prix des airbnb par nuit en moyenne (en log) par arondissement") +
  labs(x = "Arrondissements", y = "Prix par nuit en moyenne (en log)",
       caption = tag_source) + theme

# # ===== ===== Prix par arrondissement et type de logement ===== =====

ggplot(data, aes(x = neighbourhood_group_cleansed, y = log(price),
                 fill = property_type)) +
  geom_boxplot(outlier.colour = "darkblue", outlier.size = 0.5) +
  ggtitle("Prix des airbnb par nuit en moyenne (en log)
          par arondissement et par type de logement") +
  scale_fill_discrete(name = "Type de logement") + theme +
  labs(x = "Arrondissement", y = "Prix par nuit en moyenne (en log)",
       caption = tag_source)

# # ===== ===== Répartition des logements par arrondissement ===== =====

ggplot(data, aes(x = neighbourhood_group_cleansed, fill = property_type)) +
  geom_bar(width = 1, colour = "black", show.legend = T) +
  ggtitle("Répartition des logements par arrondissement") +
  scale_fill_discrete(name = "Type de logement") + theme +
  labs(x = "Arrondissement", y = "Fréquence", caption = tag_source)
```

### Correlation matrix

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
corrplot(cor(data[,features_numeric]), method = "pie", type = "lower")
```

### Spatial Heatmap

#### Evolution des prix par quartier

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE, echo=F}
by_neighbourhood <- group_by(data, neighbourhood_cleansed) %>%
  summarise(longitude = median(longitude),
            latitude = median(latitude),
            prix_median = median(price),
            prix_moyen = mean(price),
            scores_moyen = mean(review_scores_rating))

for (i in by_neighbourhood$neighbourhood_cleansed) {
  for (j in data$neighbourhood_cleansed) {
    if (i == j) {
      a <- unique(as.character(data[data$neighbourhood_cleansed==j,
                                   "neighbourhood_group_cleansed"]))
      by_neighbourhood[by_neighbourhood$neighbourhood_cleansed==i,
                       "neighbourhood_group_cleansed"] <- a
    }
  }
}

by_neighbourhood$neighbourhood_group_cleansed <-
  as.factor(by_neighbourhood$neighbourhood_group_cleansed)

height <- max(data$latitude) - min(data$latitude)
width <- max(data$longitude) - min(data$longitude)
borders <- c(bottom  = min(data$latitude)  - 0.1 * height,
             top     = max(data$latitude)  + 0.1 * height,
             left    = min(data$longitude) - 0.1 * width,
             right   = max(data$longitude) + 0.1 * width)

map <- get_stamenmap(borders, zoom = 11, maptype = "terrain")
```

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
# # ===== ===== Prix moyen par quartiers ===== =====
ggmap(map) +
  geom_point(by_neighbourhood,
             mapping = aes(x = longitude, y = latitude,
                           col = prix_moyen,
                           shape = neighbourhood_group_cleansed)) +
  scale_colour_gradient(low = "blue", high = "red") + theme +
  labs(x = "", y = "", caption = tag_source, 
       col = "Prix moyen", shape = "Arrondissement") +
  ggtitle("Prix moyen par quartier")

# # ===== ===== Score median par quartiers ===== =====
ggmap(map) +
  geom_point(by_neighbourhood,
             mapping = aes(x = longitude, y = latitude,
                           col = scores_moyen,
                           shape = neighbourhood_group_cleansed)) +
  scale_colour_gradient(low = "blue", high = "red") + theme +
  labs(x = "", y = "", caption = tag_source, col = "Score moyen") +
  ggtitle("Score median par quartier")
```

#### Evolution des prix par Arrondissement

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE, echo=F}
by_borough <- group_by(data, neighbourhood_group_cleansed) %>%
  summarise(longitude = median(longitude),
            latitude = median(latitude),
            prix_moyen = mean(price),
            prix_median = median(price),
            scores_moyen = mean(review_scores_rating),
            disponibilité_moyen = mean(availability_365))
```

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
# # ===== ===== Prix moyen par arrondissements ===== =====
ggmap(map) +
  geom_point(by_borough, shape = 18,
             mapping = aes(x = longitude, y = latitude,
                           col = prix_moyen, size = disponibilité_moyen)) +
  scale_colour_gradient(low = "blue", high = "red") +
  theme + labs(x = "", y = "", caption = tag_source,
               size = "Disponibilité annuel moyen",
               col = "Prix moyen") +
  ggtitle("Prix moyen (en log) et disponibilité
          par arrondissements") +
  geom_label(by_borough,
             mapping = aes(longitude, latitude,
                           label = neighbourhood_group_cleansed),
             size = 1.5, fontface = "bold",
             nudge_x = 0.015, nudge_y = -0.03)
```

# Linear Models 

```{r cache=TRUE,include=F,message=FALSE, warning=FALSE}
theme_models <- theme(plot.title = element_text(hjust = 0.5),
               plot.background = element_rect(fill = "#BFD5E3"),
               legend.position = "none")

tag_source_models <- "The model has been fit using 62942 samples & 30 predictor
and the dependant variable was the log of price"
```

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
# # ===== Create a subset of the data to use in prediction ===== =====

data_model <- data %>% select(-c("id", "neighbourhood_cleansed", 
                                 "latitude", "longitude", "price"))
data_model$log_price <- log(data$price)

# # ===== Create dummy variables =====

dummies <- dummyVars(log_price~., data_model, sep = "_")
new_set <- as.data.frame(predict(dummies, newdata = data_model))
data_model <- cbind(new_set,data_model$log_price)
colnames(data_model)[which(names(data_model) == "data_model$log_price")] <- "log_price"

# # ===== ===== Train / Test split ===== =====
set.seed(777)

trainIndex <- createDataPartition(data_model$log_price, 
                                  p = .8, 
                                  list = FALSE, 
                                  times = 1)

data_train <- data_model[trainIndex,]
data_test  <- data_model[-trainIndex,]

# # ===== ===== Setting up the validation methods ===== =====
K10_CV <- trainControl(method = "cv", number = 10)
```

## Ordinary Least Square model 

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
set.seed(777)

ols_fit <- train(log_price ~ ., 
                 data = data_train, 
                 method = "lm" , 
                 trControl = K10_CV)

summary(ols_fit)

ols_pred <- predict(ols_fit, data_test)

postResample(pred = ols_pred, obs = data_test$log_price)
```

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
ols_varImp <- data.frame(variables = row.names(varImp(ols_fit)$importance),
                         varImp(ols_fit)$importance)

ggplot(data = ols_varImp, mapping = aes(x=reorder(variables, Overall),
                                        y=Overall,
                                        fill=variables)) +
  coord_flip() + geom_bar(stat = "identity", position = "dodge") +
  theme_models + labs(x = "", y = "", caption = tag_source_models) +
  ggtitle("OLS: Variables d'importances") 
```

## Shrinkage models

## Ridge regression

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
set.seed(777)

ridge_fit <- train(log_price ~ ., 
                   data = data_train, 
                   method = "glmnet",
                   tuneGrid = expand.grid(alpha = 0, 
                                          lambda = seq(0, 1, 0.01)),
                   preProcess = c("scale","center"),
                   trControl = K10_CV)

ridge_fit$bestTune

ridge_pred <- predict(ridge_fit, data_test)

postResample(pred = ridge_pred, obs = data_test$log_price)
```

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
ridge_varImp <- data.frame(variables = row.names(varImp(ridge_fit)$importance),
                           varImp(ridge_fit)$importance)

ggplot(data = ridge_varImp, mapping = aes(x=reorder(variables, Overall),
                                        y=Overall,
                                        fill=variables)) +
  coord_flip() + geom_bar(stat = "identity", position = "dodge") +
  theme_models + labs(x = "", y = "", caption = tag_source_models) +
  ggtitle("Ridge regression: Variables d'importances") 
```

## Lasso regression

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
set.seed(777)

lasso_fit <- train(log_price ~ ., 
                   data = data_train, 
                   method = "glmnet",
                   tuneGrid = expand.grid(alpha = 1, 
                                          lambda = seq(0, 1, 0.01)),
                   preProcess = c("scale","center"),
                   trControl = K10_CV)

lasso_fit$bestTune

lasso_pred <- predict(lasso_fit, data_test)

postResample(pred = lasso_pred, obs = data_test$log_price)
```

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
lasso_varImp <- data.frame(variables = row.names(varImp(lasso_fit)$importance),
                           varImp(lasso_fit)$importance)

ggplot(data = lasso_varImp, mapping = aes(x=reorder(variables, Overall),
                                        y=Overall,
                                        fill=variables)) +
  coord_flip() + geom_bar(stat = "identity", position = "dodge") +
  theme_models + labs(x = "", y = "", caption = tag_source_models) +
  ggtitle("Lasso regression: Variables d'importances") 
```

# Polynomial Models 

## Polynomial plots

```{r cache=TRUE,include=T,message=FALSE, warning=FALSE, echo=F}
set.seed(777)

# We choose the number of maximum polynomial degree
max_degree <- 6

list <- c("bedrooms","minimum_nights","accommodates",
          "cleaning_fee","availability_365","beds")

for (l in list){
  RMSE <- rep(0,max_degree)
  for (d in 1:max_degree) {
    PolyRegressor <- train(as.formula(bquote(log_price ~ poly(.(as.name(l)), .(d)))),
                           data = data_train,
                           method = "lm",
                           trControl = K10_CV)
    RMSE[d]<- PolyRegressor$results$RMSE
  }
  tem_data = data.frame(1:max_degree, RMSE)
  plot <- ggplot(aes(x = 1:max_degree,y = RMSE), data = tem_data) +
    geom_line(col="red") + theme_models +
    labs(x = "Polynomial Degrees", y = "RMSE",
         caption = "The model has been fit using 62942 samples & 1 predictor
         and the dependant variable was the log of price") +
    ggtitle(paste(l,"RMSE by polynomial degrees"))
  print(plot)
}
```